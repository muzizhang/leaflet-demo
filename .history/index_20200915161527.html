<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.bootcdn.net/ajax/libs/leaflet/1.6.0/leaflet.css" rel="stylesheet">
  <title>Document</title>
  <script src="https://cdn.bootcdn.net/ajax/libs/leaflet/1.6.0/leaflet.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #mapid {
      height: 100vh;
    }
    /* .leaflet-right {
      width: 100%;
      height: 100%;
    }
    .leaflet-left {
      z-index: 99999;
    } */
  </style>
</head>
<body>
  <div id="mapid"></div>
  <script>
    // 获取图片的大小
    var imageUrl = './img/企业微信截图_16000543948073.png';
    let img = new Image();
    img.src = imageUrl;
    let width = 0;
    let height = 0;
    function gcd(width, height) {
      if (width % height) {
        return gcd(height, width % height);
      } else {
        return height;
      }
    }
    
    img.onload = function() {
      width = img.width;
      height = img.height;
      let n = gcd(width, height)
      console.log(n)
      console.log(width/n, height/n)
      // 判断最大公约数的值
      /* 
        为 1 则调用部分指定值
       */
      var imageBounds = [];
      if (n == 1) {
        if (width/n - height/n > 300) {
          imageBounds = [[`8.00`, `-3.00`], [`8.0${height/n}`, `-3.${width/n}`]];
        } else {
          imageBounds = [[`8.00`, `-3.00`], [`8.0${height/n}`, `-3.0${width/n}`]];
        }
      } else if (n > 0) {
        imageBounds = [[`${width/n}.00`, `-${height/n}.00`], [`${width/n}.0${height/n}`, `-${height/n}.0${width/n}`]];
      }
      
      console.log(imageBounds)
      var map = L.map('mapid', {
        zoomSnap: 0.1,
        minZoom: 13,
        maxZoom: 16,
        center: [(parseFloat(imageBounds[0][0]) + parseFloat(imageBounds[1][0])) / 2, (parseFloat(imageBounds[0][1]) + parseFloat(imageBounds[1][1])) / 2],
        zoom: 14,
        attributionControl: false,
        renderer: L.canvas()
      });
      console.log([(parseFloat(imageBounds[0][0]) + parseFloat(imageBounds[1][0])) / 2, (parseFloat(imageBounds[0][1]) + parseFloat(imageBounds[1][1])) / 2])
      L.imageOverlay(imageUrl, imageBounds).addTo(map);

      // 画点
      // map.on('click',function(e){
      //   L.circle(e.latlng,{radius:100,color:'red',fillColor:'red',fillOpacity:1}).addTo(map)
      // })
      // 绘制一个任意半径的圆
      // var r = 0;
      // var i = null;
      // var tempCircle = new L.circle()
      // map.on('mousedown', onmouseDown)
      // map.on('mouseup',onmouseUp);
      // map.on('mousemove',onMove)

      // function onmouseDown(e)
      // {
      //     i=e.latlng
      //     //确定圆心
      // }
      // function onMove(e) {
      //     if(i) {
      //         r = L.latLng(e.latlng).distanceTo(i)
      //         tempCircle.setLatLng(i)
      //         tempCircle.setRadius(r)
      //         tempCircle.setStyle({color:'#ff0000',fillColor:'#ff0000',fillOpacity:1})
      //         map.addLayer(tempCircle)

      //     }
      // }

      // function onmouseUp(e)
      // {
      //     r = L.latLng(e.latlng).distanceTo(i)//计算半径
      //     L.circle(i,{radius:r,color:'#ff0000',fillColor:'#ff0000',fillOpacity:1}).addTo(map)
      //     i=null
      //     r=0
      // }

      // 绘线
      var points = [],geometry=[]
      var lines = new L.polyline(points)
      var tempLines = new L.polyline([])
      map.on('click', onClick);    //点击地图
      map.on('dblclick', onDoubleClick);
      function onClick(e) {
        points.push([e.latlng.lat, e.latlng.lng])
        lines.addLatLng(e.latlng)
        map.addLayer(lines)
        const node=L.circle(e.latlng, { color: '#ff0000', fillColor: 'ff0000', fillOpacity: 1 })
        map.addLayer(node)
        geometry.push(node)
        map.on('mousemove', onMove)//双击地图

      }
      function onMove(e) {
        if (points.length > 0) {
            ls = [points[points.length - 1], [e.latlng.lat, e.latlng.lng]]
            tempLines.setLatLngs(ls)
            map.addLayer(tempLines)
        }
      }

      function onDoubleClick(e) {
        geometry.push(L.polyline(points).addTo(map))
        points = []
        lines.remove();            
        map.off('mousemove')
        tempLines.remove();
      }
    }
    
  </script>
</body>
</html> 